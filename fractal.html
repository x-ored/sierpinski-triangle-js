<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sierpinski Triangle with Full Color</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden; background: black;">
    <script>
        let scene, camera, renderer;
        let group;

        function init() {
            scene = new THREE.Scene();

            // Setup camera
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.set(0, 2, 4);  // Position the camera
            camera.lookAt(new THREE.Vector3(0, 0, 0));  // Look at the center of the scene

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            group = new THREE.Group();
            scene.add(group);

            // Create the Sierpinski fractal in 3D
            createSierpinski(3, new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(0, -1, 1));

            animate();
        }

        // Function to create a triangle with color
        function createTriangle(p1, p2, p3, color) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                p1.x, p1.y, p1.z,
                p2.x, p2.y, p2.z,
                p3.x, p3.y, p3.z,
            ]);

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            // Ensure triangles face outward (proper orientation)
            geometry.computeVertexNormals();  // Calculate normals for correct lighting and shading

            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });  // Double-sided material

            const triangle = new THREE.Mesh(geometry, material);
            return triangle;
        }

        // Recursive function to create a 3D tetrahedron (Sierpinski)
        function createTetrahedron(p1, p2, p3, p4, depth) {
            if (depth === 0) {
                // Midpoints between vertices
                const mid1 = p1.clone().lerp(p2, 0.5);
                const mid2 = p1.clone().lerp(p3, 0.5);
                const mid3 = p1.clone().lerp(p4, 0.5);
                const mid4 = p2.clone().lerp(p3, 0.5);
                const mid5 = p2.clone().lerp(p4, 0.5);
                const mid6 = p3.clone().lerp(p4, 0.5);

                // Add color to all triangles
                group.add(createTriangle(mid1, p2, mid4, 0xFF5733));  // Orange triangle
                group.add(createTriangle(mid2, mid4, p3, 0x33FF57));  // Green triangle
                group.add(createTriangle(mid3, mid5, p4, 0x3357FF));  // Blue triangle
                group.add(createTriangle(mid1, mid2, mid3, 0xFF33FF));  // Pink triangle
                group.add(createTriangle(mid4, mid5, mid6, 0xFFFF33));  // Yellow triangle

                return;
            }

            // Midpoints for the current depth
            const mid1 = p1.clone().lerp(p2, 0.5);
            const mid2 = p1.clone().lerp(p3, 0.5);
            const mid3 = p1.clone().lerp(p4, 0.5);
            const mid4 = p2.clone().lerp(p3, 0.5);
            const mid5 = p2.clone().lerp(p4, 0.5);
            const mid6 = p3.clone().lerp(p4, 0.5);

            // Recursively create smaller tetrahedrons
            createTetrahedron(p1, mid1, mid2, mid3, depth - 1);
            createTetrahedron(mid1, p2, mid4, mid5, depth - 1);
            createTetrahedron(mid2, mid4, p3, mid6, depth - 1);
            createTetrahedron(mid3, mid5, mid6, p4, depth - 1);
        }

        function createSierpinski(depth, p1, p2, p3, p4) {
            createTetrahedron(p1, p2, p3, p4, depth);
        }

        function animate() {
            // Rotate the fractal around the Y-axis
            group.rotation.y += 0.005; // Rotation speed

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Resize handler for responsive canvas
        window.addEventListener("resize", () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        init();
    </script>
</body>
</html>
